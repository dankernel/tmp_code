
1. 배경

1-1. 스케줄러
리눅스 시스템에서는 여러가지의 프로세스가 동시에 작동 할 수 있다. (멀티테스킹)
더 구체적으로는, 여러 프로세스가 매우 짧은 시간동안 조금씩 실행되기 때문에
동시에 실행 하는 것 처럼 보인다.

(웹서핑을 하면서 음악을 듣는 예제를 많이 든다.)

스케줄러는 여러 프로세스를 적절히 조금씩 실행 시키는 일을 한다.
여러 일(task)를 잘 스케줄링 해서 좋은 성능을 낸다.

스케줄러의 종류에 따라서 스케줄링 정책과 알고리즘이 다르다.

1-2. 타임슬라이스
프로세스를 나누어 실행 할 '작은 시간'을 타임슬라이스(타임쿼텀)이라고 하며,
이는 스케줄러마다 정하는 방법이 다르다.

타임슬라이스는 프로세스마다의 우선순위나 가중치와 큰 관계가 있다.
우선순위가 높고 가중치가 큰 프로세스에게 오랜 시간동안 자원(CPU)를 할당하기 때문이다.
즉, 타임슬라이스가 크다는 것은 그만큼의 오랜 시간동안 CPU를 쓴다는 것이고.
이상적인 스케줄러라면 CPU를 많이 쓰는 프로세스에게 긴 타임슬라이스를 할당 해야 할 것이다.

(작동중인 프로세스가 영상 인코더 같이 프로세스(연산)중심의 프로세스인지,
vim같이 입출력 중심의 프로세스인지에 따라서 적절한 시간 배분이 필요하다.)

타임슬라이스의 기본값이 너무 크다면 반응과 응답속도가 느려질 것이며,
너무 작다면 콘텍스트스위치 비용이 과다하기 때문에 성능 저하가 있을 것이다.

1-3. 나이스 우선순위
우선순위에 따라서 다른 타임슬라이스 배분을 위해서
프로세스마다 나이스라는 가중치 값이 존재한다.

나이스값은 -19 ~ 0 ~ 20 의 정수로 이루어져 있다.
나이스 값이 클수록 점유시간이 길고(양보를 함), 낮을수록 점유시간이 길다(양보를 안함).
(우선순위가 높을수록 나이스하지 않아서 숫자가 적을 것이다.)

1-4. 멀티코어에서의 스케줄링
다수개의 물리적인 코어나 논리적인 가상 코어가 다수개 있는경우
코어의 개수마다 스케줄링 대상인 프로세스가 들어가는 큐가 존재하고
각각의 다른 스케줄러가 작동한다.

cpu0, cpu1, cpu2, cpu3과 같이 cpu마다 따로 대기큐와 스케줄러가 작동한다.

추가) 로드 벨런싱 : 
한 cpu가 비균형적으로 일을 많이 하는 것을 방지 하고 평균을 맞추기 위해
적절한 cpu를 배당해서 처리하도록 함. 리스케줄링시 발생함.

2. O(1) 스케줄러
과거의 스케줄러는 단순히 우선순위(가중치)를 기준으로 타임슬라이스를 계산해 냈다.
가령, 우선순위가 두배 높은 프로세스가 있다면 타임슬라이스도 두배 차이가 났다.

단순한 연산에 의해 이루어졌기 때문에 시간복잡도는 O(1)이다.
추가 : CFS는 O(log N)의 성능을 갖는다.

2-1. O(1) 스케줄러의 한계
단순 연산을 했기 때문에 적절한 타임슬라이스 값이 나오지 않았다.

a. 두 프로세스의 우선순위가 1과 2라면 타임슬라이스가 100% 차이 남.
b. 두 프로세스의 우선순위가 4와 5라면 타임슬라이스가 25% 차이 남.

위의 a. b.모두 두 프로세스의 우선순위가 1씩 차이가 나는 경우인데
몇을 기준으로 1인가에 따라서 퍼센트 비율이 크게 다르게 나는 문제점이 있음.

3. CFS 스케줄링 발생
프로세스는 타임슬라이스를 할당받아서 그 시간을 다 쓸 때 까지 실행된다.
할당받은 타임슬라이스를 다 사용했는가 여부를 수시로 체크 해야 하는데,
그것은 타이머 인터럽트에서 처리한다.

3-1. 프로세스 생성
시스템콜 fork에 의해서 프로세스가 생성된다.
(구체적으로는 부모 프로세스가 복사된다. 자세한 내용은 생략한다.)

a. [fork] //프로세스 생성 함수
b. [do_fork]  //실재 함수
c. [copy_process] //복사 함수
d. [sched_fork] //스케줄링 정보 복사 함수

fork()가 실행되는 do_fork()함수의 중에 
프로세스를 복사하는 copy_process()함수 내부에
스케줄링 정보를 복사하는 sched_fork()함수에서 관련 정보를 초기화 한다.

3-1. 타이머 인터럽트
타이머 인터럽트는 특정 주기(초당 100 ~ 1000회)마다 실행된다.
매우 짧은 시간동안에 반복적으로 실행되기 때문에 핸들러 구현이 비교적 간단하다.

(인터럽트에 대한 문서는 외부문서 참조, 본 문서에서는 별도 설명 없음)

타이머 인터럽트 핸들의 흐름은 다음과 같다.

a. [지피값 증가 함수] 
b. [프로세스 시간 업데이트 함수] 
c. [...기타 함수]

a. 부팅 이후 시스템의 시간을 지피값으로 저장한다.
타이머 인터럽트가 발생 할 때마다 지피값을 증가시켜서 시스템 시간을 측정한다.
지피값에 접근해서 1씩 증가 하는 코드는 락이 걸려있다.

참고) 동기화, 락

b. 프로세스의 전체 실행시간, 타임슬라이스 값과 같은 통계값을 주기적으로 업데이트 한다.

4. CFS

a. 두 프로세스의 우선순위가 0
b. 두 프로세스의 우선순위가 10

a. b. 모두 같은 타임슬라이스를 갖는다.

/* =========================================================================== */


Task  TS
1     0.0099
2     0.0197
3     0.0149
4     0.0198
5     0.0166
6     0.0199
7     0.0174
7     0.0199
9     0.0224
10    0.0249
rq에 있는 Task 개수에따른 타임슬라이스 변화

vruntime
프로세스의 하는 일에 무관하게 공평하게 나눠가짐(DISK I/O가 없다고 가정)

DISK I/O가 있는 경우.
프로세스가 많은 경우.

구현

vruntime???
가상실행시간 =? 타임슬라이스???

